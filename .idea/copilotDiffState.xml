<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/uploads/submissions/[filename]/route.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/uploads/submissions/[filename]/route.ts" />
              <option name="originalContent" value="import { NextRequest, NextResponse } from 'next/server';&#10;}&#10;  }&#10;    return new NextResponse('Internal Server Error', { status: 500 });&#10;    console.error('Unexpected error serving submission:', err);&#10;  } catch (err) {&#10;    }&#10;      return new NextResponse('Internal Server Error', { status: 500 });&#10;      console.error('Submission serve error:', e);&#10;      }&#10;        return new NextResponse('Not Found', { status: 404 });&#10;      if (code === 'ENOENT' || code === 'ENOTDIR') {&#10;      const code = getErrorCode(e);&#10;    } catch (e: unknown) {&#10;      });&#10;        },&#10;          'Cache-Control': 'public, max-age=31536000, immutable',&#10;          'Content-Type': contentType,&#10;        headers: {&#10;        status: 200,&#10;      return new NextResponse(body, {&#10;      const body = new Blob([bytes], { type: contentType });&#10;      const bytes = new Uint8Array(data);&#10;      const contentType = getContentType(filePath);&#10;      const data = await fs.readFile(filePath);&#10;      // Check existence and read&#10;    try {&#10;&#10;    const filePath = path.join(process.cwd(), 'public', 'uploads', 'submissions', filename);&#10;&#10;    }&#10;      return new NextResponse('Not Found', { status: 404 });&#10;    if (!filename || filename.includes('..') || filename.includes('/') || filename.includes('\\')) {&#10;    // security: disallow path traversal&#10;    const { filename } = await params;&#10;  try {&#10;export async function GET(_req: NextRequest, { params }: { params: Promise&lt;{ filename: string }&gt; }) {&#10;&#10;}&#10;  return undefined;&#10;  }&#10;    return typeof code === 'string' ? code : undefined;&#10;    const code = (err as { code?: unknown }).code;&#10;  if (err &amp;&amp; typeof err === 'object' &amp;&amp; 'code' in err) {&#10;function getErrorCode(err: unknown): string | undefined {&#10;&#10;}&#10;  }&#10;      return 'application/octet-stream';&#10;    default:&#10;      return 'video/quicktime';&#10;    case '.mov':&#10;      return 'video/webm';&#10;    case '.webm':&#10;      return 'video/mp4';&#10;    case '.mp4':&#10;      return 'image/gif';&#10;    case '.gif':&#10;      return 'image/webp';&#10;    case '.webp':&#10;      return 'image/png';&#10;    case '.png':&#10;      return 'image/jpeg';&#10;    case '.jpeg':&#10;    case '.jpg':&#10;  switch (ext) {&#10;  const ext = path.extname(filePath).toLowerCase();&#10;function getContentType(filePath: string): string {&#10;&#10;export const runtime = 'nodejs';&#10;export const dynamic = 'force-dynamic';&#10;&#10;import fs from 'fs/promises';&#10;import path from 'path';&#10;&#10;" />
              <option name="updatedContent" value="import { NextRequest, NextResponse } from 'next/server';&#10;import path from 'path';&#10;import fs from 'fs/promises';&#10;&#10;export const dynamic = 'force-dynamic';&#10;export const runtime = 'nodejs';&#10;&#10;function getContentType(filePath: string): string {&#10;  const ext = path.extname(filePath).toLowerCase();&#10;  switch (ext) {&#10;    case '.jpg':&#10;    case '.jpeg':&#10;      return 'image/jpeg';&#10;    case '.png':&#10;      return 'image/png';&#10;    case '.webp':&#10;      return 'image/webp';&#10;    case '.gif':&#10;      return 'image/gif';&#10;    case '.mp4':&#10;      return 'video/mp4';&#10;    case '.webm':&#10;      return 'video/webm';&#10;    case '.mov':&#10;      return 'video/quicktime';&#10;    default:&#10;      return 'application/octet-stream';&#10;  }&#10;}&#10;&#10;function getErrorCode(err: unknown): string | undefined {&#10;  if (err &amp;&amp; typeof err === 'object' &amp;&amp; 'code' in err) {&#10;    const code = (err as { code?: unknown }).code;&#10;    return typeof code === 'string' ? code : undefined;&#10;  }&#10;  return undefined;&#10;}&#10;&#10;export async function GET(_req: NextRequest, { params }: { params: Promise&lt;{ filename: string }&gt; }) {&#10;  try {&#10;    const { filename } = await params;&#10;    // security: disallow path traversal&#10;    if (!filename || filename.includes('..') || filename.includes('/') || filename.includes('\\')) {&#10;      return new NextResponse('Not Found', { status: 404 });&#10;    }&#10;&#10;    const filePath = path.join(process.cwd(), 'public', 'uploads', 'submissions', filename);&#10;&#10;    try {&#10;      // Check existence and read&#10;      const data = await fs.readFile(filePath);&#10;      const contentType = getContentType(filePath);&#10;      const bytes = new Uint8Array(data);&#10;      const body = new Blob([bytes], { type: contentType });&#10;      return new NextResponse(body, {&#10;        status: 200,&#10;        headers: {&#10;          'Content-Type': contentType,&#10;          'Cache-Control': 'public, max-age=31536000, immutable',&#10;        },&#10;      });&#10;    } catch (e: unknown) {&#10;      const code = getErrorCode(e);&#10;      if (code === 'ENOENT' || code === 'ENOTDIR') {&#10;        return new NextResponse('Not Found', { status: 404 });&#10;      }&#10;      console.error('Submission serve error:', e);&#10;      return new NextResponse('Internal Server Error', { status: 500 });&#10;    }&#10;  } catch (err) {&#10;    console.error('Unexpected error serving submission:', err);&#10;    return new NextResponse('Internal Server Error', { status: 500 });&#10;  }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/next.config.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/next.config.ts" />
              <option name="originalContent" value="import type { NextConfig } from &quot;next&quot;;&#10;&#10;const nextConfig: NextConfig = {&#10;  async rewrites() {&#10;    return {&#10;      beforeFiles: [&#10;        { source: &quot;/unauthorized&quot;, destination: &quot;/zugriff-verweigert&quot; },&#10;      ],&#10;      afterFiles: [],&#10;      fallback: [],&#10;    };&#10;  },&#10;  serverActions: {&#10;    bodySizeLimit: '50mb',&#10;  },&#10;};&#10;&#10;export default nextConfig;&#10;" />
              <option name="updatedContent" value="import type { NextConfig } from &quot;next&quot;;&#10;&#10;const nextConfig: NextConfig = {&#10;  async rewrites() {&#10;    return {&#10;      beforeFiles: [&#10;        { source: &quot;/unauthorized&quot;, destination: &quot;/zugriff-verweigert&quot; },&#10;      ],&#10;      afterFiles: [],&#10;      fallback: [],&#10;    };&#10;  },&#10;  experimental: {&#10;    serverActions: {&#10;      bodySizeLimit: '50mb',&#10;    },&#10;  },&#10;};&#10;&#10;export default nextConfig;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/force-dark-footer.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/force-dark-footer.js" />
              <option name="updatedContent" value="const fs = require('fs');&#10;const path = require('path');&#10;const file = path.resolve(__dirname, '..', 'components', 'Footer.tsx');&#10;let src = fs.readFileSync(file, 'utf8');&#10;&#10;// Ersetzungen: Light/Dark-Mix -&gt; feste Dark-Standards&#10;src = src.replace(/text-\[#2a2520\]\s+dark:text-\[#f5f1ed\]/g, 'text-[#f5f1ed]');&#10;src = src.replace(/text-\[#6b635a\]\s+dark:text-\[#b8aea5\]/g, 'text-[#b8aea5]');&#10;src = src.replace(/hover:text-\[#d97757\]\s+dark:hover:text-\[#e89a7a\]/g, 'hover:text-[#e89a7a]');&#10;src = src.replace(/border-\[#d97757\]\/10\s+dark:border-\[#e89a7a\]\/10/g, 'border-[#e89a7a]/10');&#10;&#10;// Falls noch einzelne dark:-Reste vorhanden sind (Sicherheitsnetz):&#10;src = src.replace(/\sdark:[^\s&quot;]+/g, '');&#10;&#10;fs.writeFileSync(file, src, 'utf8');&#10;console.log('Footer.tsx dark:-Varianten entfernt und Dark als Standard gesetzt.');&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>